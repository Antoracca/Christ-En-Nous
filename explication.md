Vérifier les plugins Babel d’environnement
Une cause très fréquente d’affichage bloqué sur « Welcome to Expo » est l’usage d’un plugin Babel d’environnement (par exemple react‑native‑dotenv ou un plugin “inline env”)stackoverflow.comdocs.expo.dev. Depuis Expo SDK 51+, ces plugins écrasent la configuration d’Expo Router et empêchent le chargement des routes, provoquant l’écran par défaut. Par exemple, la documentation Expo indique que “react-native-dotenv is not compatible with expo-router… If you use the react-native-dotenv Babel plugin…you’ll see the empty state 'Welcome to Expo' screen”stackoverflow.com. De même, un autre développeur signale avoir résolu le problème en commentant ou supprimant le plugin react-native-dotenv et tout plugin d’environnement similaire (e.g. babel-plugin-transform-inline-environment-variables), puis en réinstallant avec uniquement babel-preset-expodocs.expo.dev.


Solution : Dans votre babel.config.js, supprimez toute référence à module:react-native-dotenv ou tout autre plugin d’env. Par exemple, revenez à une configuration minimale du type :
module.exports = function(api) {
  api.cache(true);
  return { presets: ['babel-preset-expo'] };
};

Ensuite, réexécutez npx expo start -c pour nettoyer le cache Metro. Assurez-vous aussi de désinstaller le paquet react-native-dotenv (ou autre bibliothèque d’env) de vos dépendances.


Utiliser les variables d’environnement d’Expo
Au lieu d’un plugin externe, Expo recommande d’utiliser son système natif d’environnement. Expo CLI charge automatiquement les variables d’environnement préfixées par EXPO_PUBLIC_ depuis un fichier .envdocs.expo.dev. Par exemple, créez un .env à la racine :
EXPO_PUBLIC_API_URL=https://exemple.com/api

Puis dans votre code JavaScript/TypeScript :
const apiUrl = process.env.EXPO_PUBLIC_API_URL;

Lors du bundling, Expo remplace process.env.EXPO_PUBLIC_API_URL par la valeur définiedocs.expo.dev. Ce mécanisme n’est pas affecté par Metro, et évite ainsi les conflits. En pratique, après avoir retiré le plugin babel d’env, veillez à adapter votre code pour utiliser process.env.EXPO_PUBLIC_*docs.expo.devdocs.expo.dev.
Vérifier la configuration Expo Router de base
Assurez-vous que votre configuration d’Expo Router respecte les recommandations officielles :


Dans package.json, "main": "expo-router/entry" doit être présent. (Vous avez déjà ajouté un index.js racine contenant import 'expo-router/entry';.)


Dans app.json, la section "expo" doit inclure le plugin "expo-router".


Votre dossier app/ doit être à la racine du projet (pas imbriqué dans un autre dossier), et contenir les fichiers de routes. Par exemple, un fichier app/index.tsx ou app/_layout.tsx. L’écran par défaut “Touch app/index.tsx” indique que Metro ne trouve aucune route valide. Vérifiez que vous avez bien placé au moins un app/index.tsx ou _layout.tsx conformément à la documentation de routage.


Désactivez toute configuration expérimentale qui pourrait interférer, comme experiments.typedRoutes dans app.json, si présente.


Éviter les « retours nuls » et les imports dynamiques
Expo Router déconseille fortement de retourner null à la racine pendant le chargementdocs.expo.dev. Par exemple, RootLayout ne doit pas renvoyer null avant que l’app soit prête, car cela empêche le rendu des routes (notamment sur le web cela ferait ignorer complètement les enfants)docs.expo.dev. Si vous utilisez un splash screen personnalisé (p. ex. UniversalSplashScreen), attention à ne pas bloquer la racine indéfiniment. De même, évitez les imports dynamiques ou require conditionnels dans vos pages ou dans _layout.tsx, car le système de routage par fichier de Expo Router nécessite de pouvoir analyser statiquement les routes. Si vous avez des hooks (useEffect, useContext, etc.) dans votre layout, isolez-les ou commentez-les temporairement pour vérifier qu’ils ne causent pas d’erreur silencieuse au montage.
Diagnostiquer l’erreur silencieuse
L’absence d’erreur en console peut indiquer que l’application plante très tôt (et que seul l’écran de bienvenue reste affiché). Pour déboguer :


Lancez en mode développement avec npx expo start --dev-client (après avoir créé un Development Build si nécessaire) ou utilisez npx expo run:android/ios. Ainsi vous pourrez voir les logs natifs/JavaScript dans la console et repérer une exception masquée.


Ouvrez les outils de développeur (console du navigateur pour le web, ou logs Metro / adb logcat pour un appareil Android) et recherchez toute erreur.


Simplifiez progressivement votre application : commentez le contenu de app/_layout.tsx et de vos écrans pour ne garder qu’un <Stack /> vide. Si cela fonctionne, réintroduisez pas à pas les composants (providers, splash screen, etc.) pour isoler le module fautif.


En résumé
Les cas les plus courants sont liés à la configuration d’environnement. Supprimez tout plugin Babel d’envstackoverflow.comdocs.expo.dev, utilisez le mécanisme Expo pour vos variables d’environnementdocs.expo.devdocs.expo.dev, et assurez-vous que le dossier app/ est correct. Ensuite, vérifiez qu’aucun de vos composants initiaux ne renvoie null ou ne déclenche d’erreur silencieuse (par exemple à cause d’un import conditionnel). En suivant cette démarche et en isolant les composants un par un, vous devriez identifier la cause du crash silencieux.
Sources : Documentation Expo Router et retours d’expérience (StackOverflow) indiquant que le plugin react-native-dotenv et autres plugins d’env breaks Expo Routerstackoverflow.comdocs.expo.dev, ainsi que la méthode Expo CLI pour charger les .envdocs.expo.devdocs.expo.dev. Ces sources confirment les recommandations sur la configuration et l’usage des variables d’environnement.Sources

Rapport d'Expertise Technique : Analyse Forensique de l'Échec de Migration Expo Router, des Conflits de Configuration Babel et des Crashs Silencieux du Runtime Natif1. Synthèse Exécutive et Hypothèse de Défaillance SystémiqueLa migration d'une architecture de navigation impérative, telle que React Navigation, vers une architecture déclarative basée sur le système de fichiers, comme Expo Router, constitue l'une des transformations les plus fondamentales qu'une application React Native puisse subir. Le scénario technique que vous décrivez — une compilation réussie affichant "Bundled 734 modules", suivie immédiatement d'un état inerte affichant l'écran par défaut "Welcome to Expo", et dégénérant en une boucle de recompilation infinie d'un seul module ("Bundled 1 module") — ne représente pas une simple erreur de configuration. Il s'agit, selon toute probabilité technique et au vu des données de recherche accumulées, d'une défaillance composée.Cette pathologie complexe résulte de la convergence de deux vecteurs d'erreurs distincts mais simultanés, qui masquent mutuellement leurs symptômes respectifs, rendant le diagnostic par les méthodes conventionnelles (logs Metro, console navigateur) inopérant.Premièrement, la persistance de l'écran "Welcome to Expo", malgré la présence avérée et vérifiée du répertoire app/ et des configurations correctes dans app.json et package.json, indique une rupture dans le mécanisme d'auto-découverte du routeur. L'analyse approfondie des conflits de plugins Babel suggère avec une très haute probabilité que l'injection des variables d'environnement critiques pour le routage (notamment EXPO_ROUTER_APP_ROOT) est interceptée ou corrompue par une configuration résiduelle, spécifiquement liée à la bibliothèque react-native-dotenv ou à une transformation AST (Abstract Syntax Tree) concurrente.1Deuxièmement, la boucle de recompilation ("1 module") associée à l'absence totale de logs JavaScript est la signature caractéristique d'un crash natif précoce (Early Native Crash). Ce type de défaillance survient au niveau du thread UI ou du thread principal Android/iOS avant même que le pont JavaScript (JS Bridge) ne soit totalement initialisé pour transmettre les exceptions à la console de développement. Dans le contexte d'Expo SDK 52/53, ce comportement est endémique aux désalignements de versions binaires des bibliothèques react-native-reanimated et react-native-safe-area-context, qui tentent d'accéder à des API natives (TurboModules ou JNI) dont la signature a changé.2Ce rapport détaille une analyse forensique de ces mécanismes, déconstruisant étape par étape pourquoi vos tentatives de correction (nettoyage de cache, simplification du _layout.tsx, ajustement du blockList Metro) n'ont pas abouti, et propose un protocole de remédiation chirurgical.2. Architecture de la Défaillance : Déconstruction des SymptômesPour comprendre pourquoi l'application se comporte de cette manière apparemment contradictoire (compile mais ne s'exécute pas), il est impératif d'analyser la séquence de démarrage d'une application Expo Router et d'identifier les points de rupture exacts.2.1 Le Paradoxe de l'Écran "Welcome to Expo"L'écran "Welcome to Expo" n'est pas une page d'erreur générique ; c'est un composant React spécifique, résidant au sein du paquet expo-router, conçu pour être rendu si et seulement si le routeur ne parvient pas à construire un arbre de navigation valide.Dans un fonctionnement nominal, Expo Router exécute la logique suivante au démarrage :Initialisation du Point d'Entrée : Le fichier expo-router/entry est chargé.Injection du Contexte : Le routeur utilise l'API require.context (spécifique au bundler Metro) pour scanner récursivement le dossier cible.Résolution du Chemin Racine : Le dossier cible est déterminé par une variable d'environnement, généralement injectée par babel-preset-expo lors de la transpilation.Montage de l'Arbre : Les fichiers trouvés dans app/ sont convertis en routes.Si vous visualisez l'écran "Welcome to Expo" alors que votre dossier app/ contient des fichiers _layout.tsx et index.tsx valides, cela signifie que l'étape 3 a échoué silencieusement. Le routeur "regarde" au mauvais endroit ou reçoit une valeur undefined pour la racine du projet. Comme nous le verrons dans la section dédiée à l'analyse Babel, ceci est typiquement causé par des interférences dans la gestion des variables d'environnement.52.2 La Signification Forensique de la Boucle "1 Module"Le symptôme le plus critique que vous avez identifié est la boucle de recompilation : Metro recompile constamment le bundle en boucle avec seulement 1 module au lieu de maintenir les 734 modules initiaux.Cette observation permet d'éliminer une erreur de logique JavaScript classique (qui afficherait une stack trace rouge) et confirme une instabilité du processus hôte. Voici la chronologie de cet échec :Bundle Initial (734 modules) : Metro compile l'intégralité de l'application JavaScript. C'est un succès syntaxique.Transmission : Le bundle est envoyé à l'appareil ou à l'émulateur.Exécution Native : Le runtime React Native commence à initialiser les modules natifs (Java/Kotlin sur Android, Obj-C/Swift sur iOS). C'est ici que Reanimated, GestureHandler, et SafeAreaContext s'initialisent.Crash Fatal (SIGSEGV / Exception Java) : Une incompatibilité binaire provoque l'arrêt brutal du processus de l'application. Contrairement à une erreur JS qui est "catchée" par le Error Boundary de React, ce crash tue l'activité Android instantanément.Redémarrage Automatique : L'outil de développement (Expo Go ou Development Build), détectant la perte de connexion, tente de recharger le contexte.Nouvelle Requête Metro : L'application redémarrée demande le bundle.Optimisation Delta (1 Module) : Metro constate qu'aucun fichier source n'a changé sur le disque depuis la dernière compilation (il y a quelques secondes). Il ne renvoie donc pas les 734 modules, mais uniquement le module d'entrée ou un delta minimal ("1 module") pour confirmer que le bundle est à jour.Répétition : L'application reçoit ce delta, tente de s'initialiser, et crashe à nouveau au même point natif.C'est ce cycle qui crée l'illusion d'une boucle infinie de compilation. Le "1 module" n'est pas une erreur de bundling ; c'est la preuve que le bundler fonctionne correctement (cache hit) mais que le client (l'app) meurt et ressuscite en boucle.73. Analyse Approfondie : Le Conflit d'Environnement (Hypothèse "Welcome Screen")La persistance de l'écran par défaut suggère une corruption de la configuration au moment de la compilation (Build-Time Configuration Corruption). Votre description mentionne une vérification minutieuse de babel.config.js, mais l'interaction entre les plugins Babel est souvent subtile et dépend de l'ordre de visite de l'AST (Abstract Syntax Tree).3.1 Le Rôle Critique de babel-preset-expoExpo Router ne fonctionne pas par magie ; il s'appuie lourdement sur babel-preset-expo. Ce preset ne se contente pas de transpiler le JavaScript moderne ; il effectue des injections de code vitales. Plus précisément, il injecte une définition globale pour process.env.EXPO_ROUTER_APP_ROOT.C'est cette variable qui informe le runtime expo-router/entry que vos routes se trouvent dans ./app.3.2 L'Antagonisme de react-native-dotenvDe nombreux projets React Native, en particulier ceux migrant depuis des versions antérieures ou React Navigation, utilisent la bibliothèque react-native-dotenv pour gérer les variables d'environnement.Cependant, cette bibliothèque opère de manière agressive. Elle est conçue pour scanner le code source à la recherche de tout motif ressemblant à process.env.VARIABLE et le remplacer statiquement par une chaîne de caractères.Le Mécanisme du Conflit :Si react-native-dotenv est présent dans la configuration Babel (même s'il semble correctement configuré), il peut s'exécuter avant ou en conflit avec le plugin interne d'Expo.Lorsqu'il rencontre l'objet global process.env (que Expo tente de peupler avec les configurations du routeur), react-native-dotenv peut le remplacer par un objet vide ou un objet contenant uniquement les variables définies dans votre fichier .env.Conséquence : La variable interne EXPO_ROUTER_APP_ROOT est écrasée ou perdue.Résultat au Runtime : Le code d'initialisation du routeur exécute require.context(process.env.EXPO_ROUTER_APP_ROOT). Si la variable est undefined, l'appel échoue ou retourne un contexte vide. Le composant <ExpoRoot /> détecte zéro route et rend le composant de repli <Tutorial />, qui est l'écran "Welcome to Expo" que vous observez.13.3 Preuves Empiriques et CorrélationLes données de recherche confirment explicitement cette incompatibilité. Le snippet 1 déclare sans équivoque : "react-native-dotenv is not compatible with expo-router. If you are using the react-native-dotenv Babel plugin, it will overwrite expo-router configuration environment variables and you'll see the empty state 'Welcome to Expo' screen."De plus, le snippet 10 rapporte un cas identique où la suppression de l'entrée ["module:react-native-dotenv", {... }] dans babel.config.js, suivie d'un nettoyage de cache, a immédiatement résolu le problème de l'écran de bienvenue.Il est crucial de noter que même si vous pensez avoir "nettoyé" le fichier Babel, la simple présence de dépendances résiduelles ou de caches Metro profonds (fichiers .metro ou node_modules/.cache) peut perpétuer ce comportement si le transformateur Babel n'est pas totalement réinitialisé.3.4 Comparaison des Stratégies de Gestion d'EnvironnementPour résoudre ce conflit, il est impératif de comprendre la différence structurelle entre l'ancienne approche et la nouvelle approche recommandée par Expo (Expo Env).Caractéristiquereact-native-dotenv (Legacy)Expo CLI Built-in Env (Recommandé)Mécanisme d'InjectionPlugin Babel (Transformation AST)Sérialisation Metro & InlineConfigurationNécessite babel.config.jsZéro configuration (Auto-détection)Syntaxe des VariablesLibre (ex: API_KEY)Préfixe obligatoire (ex: EXPO_PUBLIC_API_KEY)SécuritéRisque d'inclusion accidentelleFiltrage strict par préfixeCompatibilité RouterIncompatible (écrase le contexte)Native (conçu pour coexister)Support WebVariable selon la config WebpackSupport unifié Metro WebL'adoption du système natif d'Expo (préfixe EXPO_PUBLIC_) élimine le besoin d'intervenir sur l'AST Babel pour les variables d'environnement, garantissant ainsi que les injections internes du routeur restent intactes.14. Analyse Approfondie : Le Crash Silencieux (Hypothèse "1 Module Loop")Si le problème de variables d'environnement explique l'interface utilisateur incorrecte, il n'explique pas nécessairement la boucle de redémarrage. Cette boucle est symptomatique d'une instabilité au niveau binaire. Dans le contexte de la migration vers Expo SDK 52 (ou versions adjacentes), les suspects principaux sont react-native-reanimated et react-native-safe-area-context.4.1 L'Architecture TurboModules et JSILes versions modernes de React Native et Expo introduisent progressivement la "Nouvelle Architecture" (Fabric, TurboModules). Même si vous ne l'avez pas explicitement activée, les bibliothèques comme Reanimated utilisent intensivement le JSI (JavaScript Interface) pour communiquer directement avec le moteur C++ sans passer par le pont asynchrone JSON classique.Cette communication directe nécessite une correspondance parfaite entre la version du binaire C++ compilé dans l'APK/IPA et la version de l'interface JavaScript attendue par le code.4.2 La Désynchronisation des Versions (Version Mismatch)Lors d'une migration manuelle (mise à jour de package.json), il est fréquent de définir les versions des dépendances avec des carets (ex: ^3.10.0). Cependant, Expo SDK 52 requiert des versions extrêmement spécifiques de ces bibliothèques natives de bas niveau.Le Scénario du Crash : Si votre projet charge une version de react-native-reanimated compilée pour React Native 0.75, mais que Expo SDK 52 exécute React Native 0.76, la structure de la mémoire des objets C++ (HostObjects) sera différente.L'Exécution : Au démarrage, l'application tente d'initialiser le module Reanimated. Le code C++ tente d'accéder à un pointeur mémoire qui n'existe plus ou qui a été déplacé dans la nouvelle version de RN.Le Résultat : Une erreur de segmentation (SIGSEGV) ou une exception Java fatale (UnsatisfiedLinkError). Ce type d'erreur est si brutal qu'il termine le processus avant que React Native n'ait pu initialiser le gestionnaire d'exceptions JavaScript (LogBox). C'est pourquoi vous ne voyez aucun log dans votre console Metro.34.3 Le Rôle de react-native-safe-area-contextExpo Router injecte automatiquement un SafeAreaProvider à la racine de l'application. Si cette bibliothèque est présente mais dans une version incompatible, elle peut échouer lors de l'enregistrement de ses "View Managers" natifs.Les recherches indiquent que des avertissements de dépréciation et des incompatibilités de constructeurs Kotlin sont fréquents avec react-native-safe-area-context dans les versions récentes si elles ne sont pas strictement alignées. Un échec ici empêche le montage de la vue racine, entraînant soit un écran blanc, soit un crash immédiat si le thread UI est bloqué.24.4 L'Impact des "Worklets"Reanimated utilise des "Worklets" (petites fonctions JavaScript exécutées sur un thread séparé). L'initialisation de ce runtime secondaire est critique. Si le plugin Babel de Reanimated n'est pas positionné en dernier dans babel.config.js, ou s'il manque, le code JavaScript principal tentera d'appeler des fonctions qui n'ont pas été correctement transformées pour le runtime UI, provoquant un crash immédiat au lancement.135. Analyse des Tentatives de Résolution du ClientVous avez fourni une liste exhaustive des actions entreprises. Analysons pourquoi elles n'ont pas fonctionné, à la lumière des hypothèses ci-dessus.5.1 "Nous avons créé un fichier index.js à la racine..."Analyse : Vous avez créé un index.js important expo-router/entry.Verdict : Cette action, bien que souvent recommandée comme solution de contournement temporaire dans les issues GitHub 5, peut introduire une condition de concurrence (Race Condition). Si package.json pointe vers expo-router/entry (qui est le standard), la présence d'un index.js explicite à la racine peut confondre la résolution de Metro. Metro (inspiré de Node.js) privilégie souvent index.js comme point d'entrée par défaut si aucune configuration contraire n'est forcée. Si Metro charge votre index.js qui importe entry, qui lui-même tente d'initialiser le routeur, cela ajoute une couche d'indirection inutile. Dans le contexte actuel, cela ne résout pas le problème de fond (variables d'environnement manquantes) et peut contribuer à la complexité du débogage.5.2 "Désactivé experiments.typedRoutes..."Analyse : Désactivation du typage statique des routes.Verdict : Inefficace. Le typage des routes est une fonctionnalité de temps de compilation (TypeScript). Elle n'a aucun impact sur le runtime JavaScript ou l'initialisation native. Si le routeur ne trouve pas de routes (cause du "Welcome Screen"), le typage échouera de facto, mais désactiver le typage ne fera pas apparaître les routes.5.3 "Simplifié le app/_layout.tsx..."Analyse : Retrait des providers et du splash screen.Verdict : Pertinent pour le débogage, mais inefficace ici. Le fait que vous ne voyiez pas les console.log du _layout.tsx prouve que le code ne parvient même pas à ce stade. Le crash se produit en amont du montage du composant _layout. Vous essayez de déboguer l'intérieur de la maison alors que la clé ne tourne pas dans la serrure.5.4 "Désactivé le blockList dans metro.config.js..."Analyse : Tentative de s'assurer que Metro voit bien les fichiers.Verdict : Peu probable d'être la cause. Expo Router utilise une détection explicite via require.context. Si les fichiers sont dans app/, ils devraient être vus. Le problème n'est pas que Metro ignore les fichiers (il compile 734 modules, donc il voit votre code), mais que le Router (logique JS) ne sait pas où regarder.5.5 "Nettoyage exhaustif des caches..."Analyse : npx expo start --clear.Verdict : Nécessaire mais insuffisant. Le cache de Metro est nettoyé, mais si le problème réside dans une incompatibilité binaire (cache de build natif Android/iOS) ou dans une transformation Babel persistante (cache Babel loader), cette commande peut ne pas tout purger. De plus, si la configuration babel.config.js contient toujours le plugin fautif (dotenv), nettoyer le cache ne fera que recompiler le même code cassé.6. Stratégies de Débogage Avancé : Le "Visibility Gap"L'un des points centraux de votre frustration est l'absence de logs. C'est un phénomène classique en développement mobile hybride que nous appelons le "Visibility Gap" (Fossé de Visibilité).6.1 Pourquoi la Console est VideLa console que vous consultez (celle du terminal Metro ou du navigateur Chrome Debugger) affiche les logs qui transitent par le JavaScript Bridge.Pour qu'un console.log apparaisse :Le runtime JS doit démarrer.Le Bridge doit s'initialiser.Le message doit être sérialisé et envoyé au serveur Metro.Dans votre cas, le processus natif (l'application Android) meurt (SIGKILL/SIGSEGV) à l'étape 0 ou 1. Le pont n'existe pas encore. Il est physiquement impossible pour Metro de recevoir un log.6.2 La Solution : ADB LogcatLes logs existent, mais ils sont dans le tampon système de l'appareil Android. Pour les voir, vous devez contourner l'outillage React Native et interroger directement l'OS.Protocole d'Inspection :Assurez-vous que l'appareil est connecté et reconnu (adb devices).Ouvrez un terminal distinct (ne fermez pas Metro).Exécutez la commande de filtrage :Bashadb logcat *:E
(Le filtre *:E demande tous les logs de niveau "Error" ou "Fatal").Ce que vous allez voir :Au moment où Metro affiche "Bundled 1 module", le terminal Logcat affichera probablement une stack trace Java massive. Recherchez des mots-clés spécifiques :java.lang.UnsatisfiedLinkError : Indique que Reanimated ou une autre librairie C++ n'a pas pu charger son binaire.java.lang.ClassNotFoundException : Indique qu'un module natif (ex: SafeAreaContext) est mal lié.FATAL EXCEPTION: main : Le thread principal UI est mort.C'est cette trace qui vous donnera la "cause racine" irréfutable que vous recherchez.167. Plan de Remédiation et Architecture CibleSur la base de cette analyse forensique, voici le protocole de résolution étape par étape. Il est impératif de suivre l'ordre précis pour isoler les variables.Phase 1 : Restauration de la Visibilité du Routeur (Fix "Welcome Screen")L'objectif est de permettre à Expo Router de lire correctement EXPO_ROUTER_APP_ROOT.Suppression de react-native-dotenv :C'est l'action la plus critique. Désinstallez le paquet :Bashnpm uninstall react-native-dotenv
Ensuite, ouvrez babel.config.js et supprimez toute référence à ce plugin. Votre fichier devrait ressembler strictement à ceci :JavaScriptmodule.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins:,
  };
};
Migration des Variables d'Environnement :Si votre application dépend de variables d'environnement, renommez-les dans vos fichiers .env en ajoutant le préfixe EXPO_PUBLIC_ (ex: EXPO_PUBLIC_API_URL). Dans votre code JS, remplacez import { API_URL } from '@env' par process.env.EXPO_PUBLIC_API_URL.Phase 2 : Stabilisation du Runtime Natif (Fix "1 Module Loop")L'objectif est d'empêcher le crash binaire au démarrage.Alignement Automatique des Versions :Ne modifiez pas manuellement les versions dans package.json. Utilisez l'outil Expo pour installer les binaires validés pour votre SDK (52/53). Exécutez :Bashnpx expo install expo-router react-native-reanimated react-native-safe-area-context react-native-screens expo-linking expo-constants expo-status-bar
Cette commande va écraser les versions incompatibles (ex: Reanimated 3.10) par les versions certifiées (ex: Reanimated 3.16.1 pour SDK 52).19Nettoyage du Cache Natif :Puisque le crash est natif, le cache Metro ne suffit pas.Si vous êtes en "Bare Workflow" ou "Prebuild" (dossier android/ présent) :Bashcd android
./gradlew cleancd..```Phase 3 : Réinitialisation du Point d'EntréeSuppression du Shim index.js :Supprimez le fichier index.js que vous avez créé à la racine. Il est redondant et potentiellement conflictuel.Vérification de package.json :Assurez-vous que l'entrée est standard :JSON{
  "main": "expo-router/entry"
}
Phase 4 : Redémarrage et ValidationLancez le serveur avec nettoyage : npx expo start --clear.Si le problème persiste, lancez adb logcat *:E dans un autre terminal avant de lancer l'app sur Android pour capturer la trace native.8. ConclusionLa situation que vous rencontrez n'est pas une impasse, mais la manifestation tangible de conflits architecturaux profonds inhérents à la migration vers des frameworks "opinionated" comme Expo Router.En résumé, votre application est victime d'un conflit de configuration Babel (causé par dotenv) qui rend le routeur aveugle à vos fichiers, couplé à une incompatibilité binaire (causée par des versions natives désalignées) qui tue le processus avant qu'il ne puisse diagnostiquer sa propre cécité.En appliquant le correctif de suppression de dotenv et en forçant l'alignement des dépendances natives via npx expo install, vous devriez restaurer à la fois la détection des routes et la stabilité du runtime, permettant enfin à vos logs de debug d'apparaître et à votre application de démarrer.